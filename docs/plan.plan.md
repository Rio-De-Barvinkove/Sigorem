# План стабілізації генерації, UI, папок і ассетів

### 1) Цільовий вигляд: мікровоксельний терейн + 2.5D HD-2D

- [ ] **Генерація: критичні регресії (листопад 2025)**
  - [ ] Початкове завантаження світу займає ~5 хв, раніше стартував за секунди.
  - [ ] Під час швидкого руху до межі активних чанків відбуваються фризи; chunking втратила плавність.
  - [ ] Висота рельєфу обмежена ≈5 блоками: поверхня, одна «земля» і відразу печера → падіння в порожнечу.
  - [ ] На поверхні видно різкі стики чанків; межі читаються як квадратна сітка.
  - [ ] Початкова «safe zone»: гарантовано плоский спавн без блоків у голові, нормальна колізійна валідація.
  - [ ] Перевірити/переписати OptimizationManager: нині лише гальмує, треба виміряти й усунути деградацію.
  - [ ] Інструментарій огляду: польотний режим + регульована швидкість, X-ray/підсвітка печер, тумблер освітлення.
  - [ ] Creative/build mode: динамічне масштабування області будівництва/копання, режим камери від першої особи.
  - [ ] Інтегрувати корисні команди у внутрішню консоль (телепорт, перегенерація чанків, профілювання тощо).

- **Геометрія:** орієнтир — Lay of the Land. Логічний шар залишається воксельним (для деструкції, чанків), але видимий терейн будуємо як «мікровоксельний» меш: приховуємо внутрішні грані, робимо скоси, плавні схили, підтримуємо дрібні деталі (брівки, сходи, мости). `GridMap.set_cell_item` використовуємо тільки як тимчасовий fallback; головна мета — перейти на генерацію `ArrayMesh` / `MeshInstance3D` з власного пайплайну (`MeshOptimizer`, `Mesher`).
- **Масштаб блоку:** ціль — 0.25–0.5 м «логічного» кроку, але рендерінг об’єднує їх у більші сегменти (greedy meshing + bevel). Це дасть «мільйони мікровокселів» візуально, не перевантажуючи GPU.
- **Статика та пропси:** пропрацьовуємо бібліотеку ручних моделей (мости, будівлі, дерева) у стилі Lay of the Land, які вставлятимуться процедурно.
- **Камера/стиль:** орієнтир — Octopath Traveler (HD-2D). Камера ізометрична 3/4, глибина різкості, легка «плівкова» розмитість, bloom і піксельні текстури. Рендерінг має виглядати як 2D, хоча це 3D-сцена.
- **Проміжні кроки:** спочатку добудовуємо генерацію мешів і текстурний пайплайн, на другому етапі підключаємо постобробку (DOF, bloom, vignette) і pixel-snapping.
- **Контрольні точки:** (1) переробити `ProceduralGeneration`/`ChunkManager` на генерацію мешів; (2) створити тестову ділянку (міст і берег) для валідації стилю; (3) після затвердження підключати художні ефекти.

### 2) Чому дві папки `scripts/game/world` і `scripts/world` і як прибрати дубль

- Пояснення: необхідно тримати тільки актуальні скрипти в `scripts/game/world/`.

### 3) Чому «меню не працює» і «світ не міняється» — кореневі причини

- Відсутній BlockRegistry (або не використовується): генератор блокує встановлення ID за назвами блоків.

```gdscript
# ProceduralGeneration.gd
var mesh_index = BlockRegistry.get_mesh_index(block_id)
if mesh_index >= 0:
    gridmap.set_cell_item(Vector3i(x, y, z), mesh_index)
```

- Жорстко прошитий розмір чанка 50×50: UI змінює `chunk_size`, але генератор ігнорує й продовжує 50×50.

```gdscript
# ProceduralGeneration.gd
var chunk_start = chunk_pos * Vector2i(50, 50)
var chunk_size = Vector2i(50, 50)
```

- Chunking не знає про гравця: `TerrainGenerator` має `player`, але він не задається з `WorldGenerator`, тому апдейт чанків по руху може не працювати.

```gdscript
# TerrainGenerator.gd
if use_chunking:
    chunk_module = ChunkManager.new()
    if player:
        chunk_module.player = player
```

- Немає seed/frequency у UI + мізерні логи: неможливо перевірити детермінізм і факт застосування налаштувань.

### 5) «Як у майнкрафті» — створення/збереження світів (не пріоритет, але одразу закладемо каркас)

- Екран «Створити світ»: name, seed/randomize, preset.
- Структура на диску: `user://worlds/<world_id>/world.json` (name, seed, created_at, last_played) + `chunks/` (per-chunk data).
- `SaveLoadManager.gd`: збереження чанків (вже існує файл, але треба ув’язати з новими параметрами).
- Екран «Список світів»: Continue/Delete/Rename.

### 6) Текстури: HD-2D набір для 2.5D сцени

- Стратегія: base color без PBR, роздільність 128×128 (максимум 256×256 для великих плиток). Орієнтир — Octopath Traveler: плиткові текстури з «намальованими» шумами, дерев'яні балки, мокрі камені. Обов’язково пара варіантів «top»/«side» для блоків, щоб mesher міг комбінувати.
- Базові блоки (tileable):
  - terrain_grass_top, terrain_grass_side
  - terrain_dirt
  - terrain_stone
  - terrain_sand
  - terrain_gravel
  - terrain_snow
  - terrain_ice (напівпрозорий варіант теж)
  - terrain_clay
  - terrain_bedrock
  - wood_log_top, wood_log_side (хвоя/листяний — 2 варіанти)
  - wood_planks_oak, wood_planks_spruce
  - cobblestone, brick
  - glass (з маскою прозорості)
  - water_albedo (та 4-кадровий sheet для легкої анімації — опціонально)
- Руди (overlay на stone, по 1 текстурі-узору):
  - ore_coal, ore_iron, ore_copper, ore_tin, ore_gold
- Рослинність (alpha-cutout для `Sprite3D`/дві площини):
  - grass_clump_01..04
  - flower_red, flower_yellow, flower_blue
  - bush_small_01..02
  - cactus_01..02
  - leaves_cluster_01..02
- Натуральні об’єкти (малі пропси, lowpoly-albedo):
  - rock_small_01..03, stump_01, fallen_log_01
- Іконки для інвентаря (64×64):
  - item_wood, item_stone, item_flint, item_fiber, item_berry
  - tool_stone_axe, tool_stone_pickaxe, item_campfire, item_bandage
- Найменування: `category_name_variant.png` (наприклад, `terrain_grass_top.png`). Каталоги: `assets/textures/terrain`, `assets/textures/objects`, `assets/textures/items`.
- Додатково: підготувати палітру/lighting chart, щоб вся графіка відповідала одному «теплому сонячному» сетапу (як на референсі Lay of the Land). Для дрібних деталей (мікровокселі) — «painterly» переходи всередині плитки, а не деталізація за рахунок високої роздільності.

### 7) Тест-кейси приймання після правок

- Зміна `chunk_size` у UI → інша кількість блоків по осі (видимо в кадрі).
- Встановлення `seed` A і B → різні патерни рельєфу; повторне встановлення A → той самий рельєф.
- Рух гравця → підвантаження/вивантаження чанків (видно в логах і HUD).
- Без BlockRegistry → генерація працює через fallback; із BlockRegistry → використовує реєстр.
- WASD управління → рух гравця працює на W/A/S/D замість стрілочок.
- Mesh optimization → менше вершин/трикутників у профілі (профілювальник Godot).
- Frustum culling → чанки поза камерою не рендеряться (профілювальник).
- Chunk boundaries → немає провалів на стиках чанків (візуальна перевірка).

### To-dos

#### Генерація світу — пріоритет №1 (мікровокселі + керування параметрами)
- [ ] Побудувати новий mesh-пайплайн: генерувати чанки у ArrayMesh/MeshInstance3D, залишити GridMap лише як debug.
- [ ] Реалізувати greedy meshing з bevel/скосами під «мікровоксельний» стиль Lay of the Land.
- [ ] Зібрати тестову сцену (міст + берег + схили) для перевірки стилю до/після.
- [ ] Додати fallback get_mesh_index_for_block у ProceduralGeneration і замінити виклики. (перевірити після нового пайплайну)

#### Генерація — оптимізація та якість
- [ ] Mesh Optimization: реалізувати greedy mesh generation (оновити під новий пайплайн).
- [ ] Large-scale structures (гори, каньйони).
- [ ] Cave generation (3D шум для підземель).
- [ ] Erosion simulation (природніший рельєф).

#### Управління і UI
- [ ] Створити input actions: move_left (A), move_right (D), move_forward (W), move_back (S).
- [ ] Замінити Input.get_vector в PlayerController.gd на нові actions.
- [ ] Перевірити/оновити камеру (Q/E обертання або альтернативні кнопки).
- [ ] Оновити GAME_CONTROLS.md з правильними клавішами (WASD).

#### Структура проекту
- [ ] Перевірити scripts/core/*.uid — якщо немає основних файлів, видалити .uid.
- [ ] Видалити дублікати .uid файлів без основних скриптів.

#### Документація
- [ ] Оновити/архівувати md: usage, implementation_plan, atlas_structure, README refs.

#### Система світів (після стабілізації генерації)
- [ ] Скелет Create/Load World, user://worlds/<id>/world.json.
- [ ] Зв'язати SaveLoadManager з новими параметрами (seed, chunks).

#### Ассети та візуал (HD-2D)
- [ ] Намалювати базовий пак текстур згідно списку (terrain, ore, flora, items).
- [ ] Підібрати постобробку/профіль освітлення для 2.5D (DOF, bloom, vignette, pixel snap) — реалізувати, коли з’явиться перший art-pass.

#### Тестування
- [ ] Скрипт тестування: змінити параметри і перевірити ефекти в логах/екрані.
- [ ] Performance test: FPS з різною кількістю чанків.
- [ ] Memory test: витрата пам'яті при русі.
- [ ] Generation quality: візуальна перевірка без артефактів.
- [ ] Chunk loading: плавність завантаження/вивантаження.
- [ ] Building/breaking: лагів при модифікації блоків.


